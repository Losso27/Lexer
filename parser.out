Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     program -> funclist
Rule 3     program -> epsilon
Rule 4     funclist -> funcdef funclistaux
Rule 5     funclistaux -> funclist
Rule 6     funclistaux -> epsilon
Rule 7     funcdef -> DEF IDENTF LPAREN paramlist RPAREN LBRACE statelist RBRACE
Rule 8     paramlist -> type IDENT paramlistaux
Rule 9     paramlist -> epsilon
Rule 10    paramlistaux -> COLON paramlist
Rule 11    paramlistaux -> epsilon
Rule 12    statelist -> statement statelistaux
Rule 13    statelistaux -> statelist
Rule 14    statelistaux -> epsilon
Rule 15    statement -> vardecl SEMICOLON
Rule 16    statement -> atribstat SEMICOLON
Rule 17    statement -> printstat SEMICOLON
Rule 18    statement -> readstat SEMICOLON
Rule 19    statement -> returnstat SEMICOLON
Rule 20    statement -> ifstat
Rule 21    statement -> forstat
Rule 22    statement -> LBRACE statelist RBRACE
Rule 23    statement -> BREAK SEMICOLON
Rule 24    statement -> SEMICOLON
Rule 25    forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN
Rule 26    ifstat -> IF LPAREN expression RPAREN statement ifstataux
Rule 27    ifstataux -> ELSE statement
Rule 28    ifstataux -> epsilon
Rule 29    returnstat -> RETURN
Rule 30    printstat -> PRINT expression
Rule 31    readstat -> READ expression
Rule 32    atribstat -> lvalue EQUAL atribstat2
Rule 33    atribstat2 -> expression
Rule 34    atribstat2 -> allocexpression
Rule 35    atribstat2 -> funccall
Rule 36    funccall -> IDENTF LPAREN paramlistcall RPAREN
Rule 37    paramlistcall -> IDENT paramlistcallaux
Rule 38    paramlistcall -> epsilon
Rule 39    paramlistcallaux -> COLON paramlistcall
Rule 40    paramlistcallaux -> epsilon
Rule 41    allocexpression -> NEW type numexpressionvectoraux
Rule 42    expression -> numexpression expressionaux
Rule 43    expressionaux -> COMPARISON numexpression
Rule 44    expressionaux -> epsilon
Rule 45    numexpressionvector -> LBRACKET numexpression RBRACKET numexpressionvectoraux
Rule 46    numexpressionvectoraux -> numexpressionvector
Rule 47    numexpressionvectoraux -> epsilon
Rule 48    numexpression -> term numexpressionaux
Rule 49    numexpressionaux -> numexpression2
Rule 50    numexpressionaux -> epsilon
Rule 51    numexpression2 -> SIGNAL term numexpressionaux
Rule 52    term -> unaryexpr termaux
Rule 53    termaux -> term2
Rule 54    termaux -> epsilon
Rule 55    term2 -> MATH unaryexpr termaux
Rule 56    unaryexpr -> SIGNAL factor
Rule 57    unaryexpr -> factor
Rule 58    factor -> INTCONST
Rule 59    factor -> STRINGCONST
Rule 60    factor -> FLOATCONST
Rule 61    factor -> NULL
Rule 62    factor -> lvalue
Rule 63    factor -> LPAREN numexpression RPAREN
Rule 64    lvalue -> IDENT numexpressionvectoraux
Rule 65    vardecl -> type IDENT vardeclaux
Rule 66    vardeclaux -> vardecl2
Rule 67    vardeclaux -> epsilon
Rule 68    vardecl2 -> LBRACKET INTCONST RBRACKET vardeclaux
Rule 69    type -> INT
Rule 70    type -> FLOAT
Rule 71    type -> STRING
Rule 72    epsilon -> <empty>

Terminals, with rules where they appear

BREAK                : 23
COLON                : 10 39
COMPARISON           : 43
DEF                  : 7
ELSE                 : 27
EQUAL                : 32
FLOAT                : 70
FLOATCONST           : 60
FOR                  : 25
IDENT                : 8 37 64 65
IDENTF               : 7 36
IF                   : 26
INT                  : 69
INTCONST             : 58 68
LBRACE               : 7 22
LBRACKET             : 45 68
LPAREN               : 7 25 26 36 63
MATH                 : 55
NEW                  : 41
NULL                 : 61
PRINT                : 30
RBRACE               : 7 22
RBRACKET             : 45 68
READ                 : 31
RETURN               : 29
RPAREN               : 7 25 26 36 63
SEMICOLON            : 15 16 17 18 19 23 24 25 25
SIGNAL               : 51 56
STRING               : 71
STRINGCONST          : 59
error                : 

Nonterminals, with rules where they appear

allocexpression      : 34
atribstat            : 16 25 25
atribstat2           : 32
epsilon              : 3 6 9 11 14 28 38 40 44 47 50 54 67
expression           : 25 26 30 31 33
expressionaux        : 42
factor               : 56 57
forstat              : 21
funccall             : 35
funcdef              : 4
funclist             : 2 5
funclistaux          : 4
ifstat               : 20
ifstataux            : 26
lvalue               : 32 62
numexpression        : 42 43 45 63
numexpression2       : 49
numexpressionaux     : 48 51
numexpressionvector  : 46
numexpressionvectoraux : 41 45 64
paramlist            : 7 10
paramlistaux         : 8
paramlistcall        : 36 39
paramlistcallaux     : 37
printstat            : 17
program              : 0
readstat             : 18
returnstat           : 19
statelist            : 7 13 22
statelistaux         : 12
statement            : 1 12 26 27
term                 : 48 51
term2                : 53
termaux              : 52 55
type                 : 8 41 65
unaryexpr            : 52 55
vardecl              : 15
vardecl2             : 66
vardeclaux           : 65 68

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) program -> . funclist
    (3) program -> . epsilon
    (15) statement -> . vardecl SEMICOLON
    (16) statement -> . atribstat SEMICOLON
    (17) statement -> . printstat SEMICOLON
    (18) statement -> . readstat SEMICOLON
    (19) statement -> . returnstat SEMICOLON
    (20) statement -> . ifstat
    (21) statement -> . forstat
    (22) statement -> . LBRACE statelist RBRACE
    (23) statement -> . BREAK SEMICOLON
    (24) statement -> . SEMICOLON
    (4) funclist -> . funcdef funclistaux
    (72) epsilon -> .
    (65) vardecl -> . type IDENT vardeclaux
    (32) atribstat -> . lvalue EQUAL atribstat2
    (30) printstat -> . PRINT expression
    (31) readstat -> . READ expression
    (29) returnstat -> . RETURN
    (26) ifstat -> . IF LPAREN expression RPAREN statement ifstataux
    (25) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN
    (7) funcdef -> . DEF IDENTF LPAREN paramlist RPAREN LBRACE statelist RBRACE
    (69) type -> . INT
    (70) type -> . FLOAT
    (71) type -> . STRING
    (64) lvalue -> . IDENT numexpressionvectoraux

    LBRACE          shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    $end            reduce using rule 72 (epsilon -> .)
    PRINT           shift and go to state 19
    READ            shift and go to state 20
    RETURN          shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    DEF             shift and go to state 24
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    STRING          shift and go to state 27
    IDENT           shift and go to state 17

    program                        shift and go to state 1
    statement                      shift and go to state 2
    funclist                       shift and go to state 3
    epsilon                        shift and go to state 4
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    funcdef                        shift and go to state 15
    type                           shift and go to state 16
    lvalue                         shift and go to state 18

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .

    $end            reduce using rule 1 (program -> statement .)


state 3

    (2) program -> funclist .

    $end            reduce using rule 2 (program -> funclist .)


state 4

    (3) program -> epsilon .

    $end            reduce using rule 3 (program -> epsilon .)


state 5

    (15) statement -> vardecl . SEMICOLON

    SEMICOLON       shift and go to state 28


state 6

    (24) statement -> SEMICOLON .

    $end            reduce using rule 24 (statement -> SEMICOLON .)
    LBRACE          reduce using rule 24 (statement -> SEMICOLON .)
    BREAK           reduce using rule 24 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 24 (statement -> SEMICOLON .)
    PRINT           reduce using rule 24 (statement -> SEMICOLON .)
    READ            reduce using rule 24 (statement -> SEMICOLON .)
    RETURN          reduce using rule 24 (statement -> SEMICOLON .)
    IF              reduce using rule 24 (statement -> SEMICOLON .)
    FOR             reduce using rule 24 (statement -> SEMICOLON .)
    INT             reduce using rule 24 (statement -> SEMICOLON .)
    FLOAT           reduce using rule 24 (statement -> SEMICOLON .)
    STRING          reduce using rule 24 (statement -> SEMICOLON .)
    IDENT           reduce using rule 24 (statement -> SEMICOLON .)
    RBRACE          reduce using rule 24 (statement -> SEMICOLON .)
    ELSE            reduce using rule 24 (statement -> SEMICOLON .)


state 7

    (16) statement -> atribstat . SEMICOLON

    SEMICOLON       shift and go to state 29


state 8

    (17) statement -> printstat . SEMICOLON

    SEMICOLON       shift and go to state 30


state 9

    (18) statement -> readstat . SEMICOLON

    SEMICOLON       shift and go to state 31


state 10

    (19) statement -> returnstat . SEMICOLON

    SEMICOLON       shift and go to state 32


state 11

    (20) statement -> ifstat .

    $end            reduce using rule 20 (statement -> ifstat .)
    LBRACE          reduce using rule 20 (statement -> ifstat .)
    BREAK           reduce using rule 20 (statement -> ifstat .)
    SEMICOLON       reduce using rule 20 (statement -> ifstat .)
    PRINT           reduce using rule 20 (statement -> ifstat .)
    READ            reduce using rule 20 (statement -> ifstat .)
    RETURN          reduce using rule 20 (statement -> ifstat .)
    IF              reduce using rule 20 (statement -> ifstat .)
    FOR             reduce using rule 20 (statement -> ifstat .)
    INT             reduce using rule 20 (statement -> ifstat .)
    FLOAT           reduce using rule 20 (statement -> ifstat .)
    STRING          reduce using rule 20 (statement -> ifstat .)
    IDENT           reduce using rule 20 (statement -> ifstat .)
    RBRACE          reduce using rule 20 (statement -> ifstat .)
    ELSE            reduce using rule 20 (statement -> ifstat .)


state 12

    (21) statement -> forstat .

    $end            reduce using rule 21 (statement -> forstat .)
    LBRACE          reduce using rule 21 (statement -> forstat .)
    BREAK           reduce using rule 21 (statement -> forstat .)
    SEMICOLON       reduce using rule 21 (statement -> forstat .)
    PRINT           reduce using rule 21 (statement -> forstat .)
    READ            reduce using rule 21 (statement -> forstat .)
    RETURN          reduce using rule 21 (statement -> forstat .)
    IF              reduce using rule 21 (statement -> forstat .)
    FOR             reduce using rule 21 (statement -> forstat .)
    INT             reduce using rule 21 (statement -> forstat .)
    FLOAT           reduce using rule 21 (statement -> forstat .)
    STRING          reduce using rule 21 (statement -> forstat .)
    IDENT           reduce using rule 21 (statement -> forstat .)
    RBRACE          reduce using rule 21 (statement -> forstat .)
    ELSE            reduce using rule 21 (statement -> forstat .)


state 13

    (22) statement -> LBRACE . statelist RBRACE
    (12) statelist -> . statement statelistaux
    (15) statement -> . vardecl SEMICOLON
    (16) statement -> . atribstat SEMICOLON
    (17) statement -> . printstat SEMICOLON
    (18) statement -> . readstat SEMICOLON
    (19) statement -> . returnstat SEMICOLON
    (20) statement -> . ifstat
    (21) statement -> . forstat
    (22) statement -> . LBRACE statelist RBRACE
    (23) statement -> . BREAK SEMICOLON
    (24) statement -> . SEMICOLON
    (65) vardecl -> . type IDENT vardeclaux
    (32) atribstat -> . lvalue EQUAL atribstat2
    (30) printstat -> . PRINT expression
    (31) readstat -> . READ expression
    (29) returnstat -> . RETURN
    (26) ifstat -> . IF LPAREN expression RPAREN statement ifstataux
    (25) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN
    (69) type -> . INT
    (70) type -> . FLOAT
    (71) type -> . STRING
    (64) lvalue -> . IDENT numexpressionvectoraux

    LBRACE          shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    PRINT           shift and go to state 19
    READ            shift and go to state 20
    RETURN          shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    STRING          shift and go to state 27
    IDENT           shift and go to state 17

    statelist                      shift and go to state 33
    statement                      shift and go to state 34
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    type                           shift and go to state 16
    lvalue                         shift and go to state 18

state 14

    (23) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 35


state 15

    (4) funclist -> funcdef . funclistaux
    (5) funclistaux -> . funclist
    (6) funclistaux -> . epsilon
    (4) funclist -> . funcdef funclistaux
    (72) epsilon -> .
    (7) funcdef -> . DEF IDENTF LPAREN paramlist RPAREN LBRACE statelist RBRACE

    $end            reduce using rule 72 (epsilon -> .)
    DEF             shift and go to state 24

    funcdef                        shift and go to state 15
    funclistaux                    shift and go to state 36
    funclist                       shift and go to state 37
    epsilon                        shift and go to state 38

state 16

    (65) vardecl -> type . IDENT vardeclaux

    IDENT           shift and go to state 39


state 17

    (64) lvalue -> IDENT . numexpressionvectoraux
    (46) numexpressionvectoraux -> . numexpressionvector
    (47) numexpressionvectoraux -> . epsilon
    (45) numexpressionvector -> . LBRACKET numexpression RBRACKET numexpressionvectoraux
    (72) epsilon -> .

    LBRACKET        shift and go to state 43
    EQUAL           reduce using rule 72 (epsilon -> .)
    MATH            reduce using rule 72 (epsilon -> .)
    SIGNAL          reduce using rule 72 (epsilon -> .)
    COMPARISON      reduce using rule 72 (epsilon -> .)
    SEMICOLON       reduce using rule 72 (epsilon -> .)
    RBRACKET        reduce using rule 72 (epsilon -> .)
    RPAREN          reduce using rule 72 (epsilon -> .)

    numexpressionvectoraux         shift and go to state 40
    numexpressionvector            shift and go to state 41
    epsilon                        shift and go to state 42

state 18

    (32) atribstat -> lvalue . EQUAL atribstat2

    EQUAL           shift and go to state 44


state 19

    (30) printstat -> PRINT . expression
    (42) expression -> . numexpression expressionaux
    (48) numexpression -> . term numexpressionaux
    (52) term -> . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    expression                     shift and go to state 45
    numexpression                  shift and go to state 46
    term                           shift and go to state 47
    unaryexpr                      shift and go to state 48
    factor                         shift and go to state 50
    lvalue                         shift and go to state 55

state 20

    (31) readstat -> READ . expression
    (42) expression -> . numexpression expressionaux
    (48) numexpression -> . term numexpressionaux
    (52) term -> . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    expression                     shift and go to state 57
    numexpression                  shift and go to state 46
    term                           shift and go to state 47
    unaryexpr                      shift and go to state 48
    factor                         shift and go to state 50
    lvalue                         shift and go to state 55

state 21

    (29) returnstat -> RETURN .

    SEMICOLON       reduce using rule 29 (returnstat -> RETURN .)


state 22

    (26) ifstat -> IF . LPAREN expression RPAREN statement ifstataux

    LPAREN          shift and go to state 58


state 23

    (25) forstat -> FOR . LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN

    LPAREN          shift and go to state 59


state 24

    (7) funcdef -> DEF . IDENTF LPAREN paramlist RPAREN LBRACE statelist RBRACE

    IDENTF          shift and go to state 60


state 25

    (69) type -> INT .

    IDENT           reduce using rule 69 (type -> INT .)
    LBRACKET        reduce using rule 69 (type -> INT .)
    SEMICOLON       reduce using rule 69 (type -> INT .)
    RPAREN          reduce using rule 69 (type -> INT .)


state 26

    (70) type -> FLOAT .

    IDENT           reduce using rule 70 (type -> FLOAT .)
    LBRACKET        reduce using rule 70 (type -> FLOAT .)
    SEMICOLON       reduce using rule 70 (type -> FLOAT .)
    RPAREN          reduce using rule 70 (type -> FLOAT .)


state 27

    (71) type -> STRING .

    IDENT           reduce using rule 71 (type -> STRING .)
    LBRACKET        reduce using rule 71 (type -> STRING .)
    SEMICOLON       reduce using rule 71 (type -> STRING .)
    RPAREN          reduce using rule 71 (type -> STRING .)


state 28

    (15) statement -> vardecl SEMICOLON .

    $end            reduce using rule 15 (statement -> vardecl SEMICOLON .)
    LBRACE          reduce using rule 15 (statement -> vardecl SEMICOLON .)
    BREAK           reduce using rule 15 (statement -> vardecl SEMICOLON .)
    SEMICOLON       reduce using rule 15 (statement -> vardecl SEMICOLON .)
    PRINT           reduce using rule 15 (statement -> vardecl SEMICOLON .)
    READ            reduce using rule 15 (statement -> vardecl SEMICOLON .)
    RETURN          reduce using rule 15 (statement -> vardecl SEMICOLON .)
    IF              reduce using rule 15 (statement -> vardecl SEMICOLON .)
    FOR             reduce using rule 15 (statement -> vardecl SEMICOLON .)
    INT             reduce using rule 15 (statement -> vardecl SEMICOLON .)
    FLOAT           reduce using rule 15 (statement -> vardecl SEMICOLON .)
    STRING          reduce using rule 15 (statement -> vardecl SEMICOLON .)
    IDENT           reduce using rule 15 (statement -> vardecl SEMICOLON .)
    RBRACE          reduce using rule 15 (statement -> vardecl SEMICOLON .)
    ELSE            reduce using rule 15 (statement -> vardecl SEMICOLON .)


state 29

    (16) statement -> atribstat SEMICOLON .

    $end            reduce using rule 16 (statement -> atribstat SEMICOLON .)
    LBRACE          reduce using rule 16 (statement -> atribstat SEMICOLON .)
    BREAK           reduce using rule 16 (statement -> atribstat SEMICOLON .)
    SEMICOLON       reduce using rule 16 (statement -> atribstat SEMICOLON .)
    PRINT           reduce using rule 16 (statement -> atribstat SEMICOLON .)
    READ            reduce using rule 16 (statement -> atribstat SEMICOLON .)
    RETURN          reduce using rule 16 (statement -> atribstat SEMICOLON .)
    IF              reduce using rule 16 (statement -> atribstat SEMICOLON .)
    FOR             reduce using rule 16 (statement -> atribstat SEMICOLON .)
    INT             reduce using rule 16 (statement -> atribstat SEMICOLON .)
    FLOAT           reduce using rule 16 (statement -> atribstat SEMICOLON .)
    STRING          reduce using rule 16 (statement -> atribstat SEMICOLON .)
    IDENT           reduce using rule 16 (statement -> atribstat SEMICOLON .)
    RBRACE          reduce using rule 16 (statement -> atribstat SEMICOLON .)
    ELSE            reduce using rule 16 (statement -> atribstat SEMICOLON .)


state 30

    (17) statement -> printstat SEMICOLON .

    $end            reduce using rule 17 (statement -> printstat SEMICOLON .)
    LBRACE          reduce using rule 17 (statement -> printstat SEMICOLON .)
    BREAK           reduce using rule 17 (statement -> printstat SEMICOLON .)
    SEMICOLON       reduce using rule 17 (statement -> printstat SEMICOLON .)
    PRINT           reduce using rule 17 (statement -> printstat SEMICOLON .)
    READ            reduce using rule 17 (statement -> printstat SEMICOLON .)
    RETURN          reduce using rule 17 (statement -> printstat SEMICOLON .)
    IF              reduce using rule 17 (statement -> printstat SEMICOLON .)
    FOR             reduce using rule 17 (statement -> printstat SEMICOLON .)
    INT             reduce using rule 17 (statement -> printstat SEMICOLON .)
    FLOAT           reduce using rule 17 (statement -> printstat SEMICOLON .)
    STRING          reduce using rule 17 (statement -> printstat SEMICOLON .)
    IDENT           reduce using rule 17 (statement -> printstat SEMICOLON .)
    RBRACE          reduce using rule 17 (statement -> printstat SEMICOLON .)
    ELSE            reduce using rule 17 (statement -> printstat SEMICOLON .)


state 31

    (18) statement -> readstat SEMICOLON .

    $end            reduce using rule 18 (statement -> readstat SEMICOLON .)
    LBRACE          reduce using rule 18 (statement -> readstat SEMICOLON .)
    BREAK           reduce using rule 18 (statement -> readstat SEMICOLON .)
    SEMICOLON       reduce using rule 18 (statement -> readstat SEMICOLON .)
    PRINT           reduce using rule 18 (statement -> readstat SEMICOLON .)
    READ            reduce using rule 18 (statement -> readstat SEMICOLON .)
    RETURN          reduce using rule 18 (statement -> readstat SEMICOLON .)
    IF              reduce using rule 18 (statement -> readstat SEMICOLON .)
    FOR             reduce using rule 18 (statement -> readstat SEMICOLON .)
    INT             reduce using rule 18 (statement -> readstat SEMICOLON .)
    FLOAT           reduce using rule 18 (statement -> readstat SEMICOLON .)
    STRING          reduce using rule 18 (statement -> readstat SEMICOLON .)
    IDENT           reduce using rule 18 (statement -> readstat SEMICOLON .)
    RBRACE          reduce using rule 18 (statement -> readstat SEMICOLON .)
    ELSE            reduce using rule 18 (statement -> readstat SEMICOLON .)


state 32

    (19) statement -> returnstat SEMICOLON .

    $end            reduce using rule 19 (statement -> returnstat SEMICOLON .)
    LBRACE          reduce using rule 19 (statement -> returnstat SEMICOLON .)
    BREAK           reduce using rule 19 (statement -> returnstat SEMICOLON .)
    SEMICOLON       reduce using rule 19 (statement -> returnstat SEMICOLON .)
    PRINT           reduce using rule 19 (statement -> returnstat SEMICOLON .)
    READ            reduce using rule 19 (statement -> returnstat SEMICOLON .)
    RETURN          reduce using rule 19 (statement -> returnstat SEMICOLON .)
    IF              reduce using rule 19 (statement -> returnstat SEMICOLON .)
    FOR             reduce using rule 19 (statement -> returnstat SEMICOLON .)
    INT             reduce using rule 19 (statement -> returnstat SEMICOLON .)
    FLOAT           reduce using rule 19 (statement -> returnstat SEMICOLON .)
    STRING          reduce using rule 19 (statement -> returnstat SEMICOLON .)
    IDENT           reduce using rule 19 (statement -> returnstat SEMICOLON .)
    RBRACE          reduce using rule 19 (statement -> returnstat SEMICOLON .)
    ELSE            reduce using rule 19 (statement -> returnstat SEMICOLON .)


state 33

    (22) statement -> LBRACE statelist . RBRACE

    RBRACE          shift and go to state 61


state 34

    (12) statelist -> statement . statelistaux
    (13) statelistaux -> . statelist
    (14) statelistaux -> . epsilon
    (12) statelist -> . statement statelistaux
    (72) epsilon -> .
    (15) statement -> . vardecl SEMICOLON
    (16) statement -> . atribstat SEMICOLON
    (17) statement -> . printstat SEMICOLON
    (18) statement -> . readstat SEMICOLON
    (19) statement -> . returnstat SEMICOLON
    (20) statement -> . ifstat
    (21) statement -> . forstat
    (22) statement -> . LBRACE statelist RBRACE
    (23) statement -> . BREAK SEMICOLON
    (24) statement -> . SEMICOLON
    (65) vardecl -> . type IDENT vardeclaux
    (32) atribstat -> . lvalue EQUAL atribstat2
    (30) printstat -> . PRINT expression
    (31) readstat -> . READ expression
    (29) returnstat -> . RETURN
    (26) ifstat -> . IF LPAREN expression RPAREN statement ifstataux
    (25) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN
    (69) type -> . INT
    (70) type -> . FLOAT
    (71) type -> . STRING
    (64) lvalue -> . IDENT numexpressionvectoraux

    RBRACE          reduce using rule 72 (epsilon -> .)
    LBRACE          shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    PRINT           shift and go to state 19
    READ            shift and go to state 20
    RETURN          shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    STRING          shift and go to state 27
    IDENT           shift and go to state 17

    statement                      shift and go to state 34
    statelistaux                   shift and go to state 62
    statelist                      shift and go to state 63
    epsilon                        shift and go to state 64
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    type                           shift and go to state 16
    lvalue                         shift and go to state 18

state 35

    (23) statement -> BREAK SEMICOLON .

    $end            reduce using rule 23 (statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 23 (statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 23 (statement -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 23 (statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 23 (statement -> BREAK SEMICOLON .)
    READ            reduce using rule 23 (statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 23 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 23 (statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 23 (statement -> BREAK SEMICOLON .)
    INT             reduce using rule 23 (statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 23 (statement -> BREAK SEMICOLON .)
    STRING          reduce using rule 23 (statement -> BREAK SEMICOLON .)
    IDENT           reduce using rule 23 (statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 23 (statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 23 (statement -> BREAK SEMICOLON .)


state 36

    (4) funclist -> funcdef funclistaux .

    $end            reduce using rule 4 (funclist -> funcdef funclistaux .)


state 37

    (5) funclistaux -> funclist .

    $end            reduce using rule 5 (funclistaux -> funclist .)


state 38

    (6) funclistaux -> epsilon .

    $end            reduce using rule 6 (funclistaux -> epsilon .)


state 39

    (65) vardecl -> type IDENT . vardeclaux
    (66) vardeclaux -> . vardecl2
    (67) vardeclaux -> . epsilon
    (68) vardecl2 -> . LBRACKET INTCONST RBRACKET vardeclaux
    (72) epsilon -> .

    LBRACKET        shift and go to state 68
    SEMICOLON       reduce using rule 72 (epsilon -> .)

    vardeclaux                     shift and go to state 65
    vardecl2                       shift and go to state 66
    epsilon                        shift and go to state 67

state 40

    (64) lvalue -> IDENT numexpressionvectoraux .

    EQUAL           reduce using rule 64 (lvalue -> IDENT numexpressionvectoraux .)
    MATH            reduce using rule 64 (lvalue -> IDENT numexpressionvectoraux .)
    SIGNAL          reduce using rule 64 (lvalue -> IDENT numexpressionvectoraux .)
    COMPARISON      reduce using rule 64 (lvalue -> IDENT numexpressionvectoraux .)
    SEMICOLON       reduce using rule 64 (lvalue -> IDENT numexpressionvectoraux .)
    RBRACKET        reduce using rule 64 (lvalue -> IDENT numexpressionvectoraux .)
    RPAREN          reduce using rule 64 (lvalue -> IDENT numexpressionvectoraux .)


state 41

    (46) numexpressionvectoraux -> numexpressionvector .

    EQUAL           reduce using rule 46 (numexpressionvectoraux -> numexpressionvector .)
    MATH            reduce using rule 46 (numexpressionvectoraux -> numexpressionvector .)
    SIGNAL          reduce using rule 46 (numexpressionvectoraux -> numexpressionvector .)
    COMPARISON      reduce using rule 46 (numexpressionvectoraux -> numexpressionvector .)
    SEMICOLON       reduce using rule 46 (numexpressionvectoraux -> numexpressionvector .)
    RBRACKET        reduce using rule 46 (numexpressionvectoraux -> numexpressionvector .)
    RPAREN          reduce using rule 46 (numexpressionvectoraux -> numexpressionvector .)


state 42

    (47) numexpressionvectoraux -> epsilon .

    EQUAL           reduce using rule 47 (numexpressionvectoraux -> epsilon .)
    MATH            reduce using rule 47 (numexpressionvectoraux -> epsilon .)
    SIGNAL          reduce using rule 47 (numexpressionvectoraux -> epsilon .)
    COMPARISON      reduce using rule 47 (numexpressionvectoraux -> epsilon .)
    SEMICOLON       reduce using rule 47 (numexpressionvectoraux -> epsilon .)
    RBRACKET        reduce using rule 47 (numexpressionvectoraux -> epsilon .)
    RPAREN          reduce using rule 47 (numexpressionvectoraux -> epsilon .)


state 43

    (45) numexpressionvector -> LBRACKET . numexpression RBRACKET numexpressionvectoraux
    (48) numexpression -> . term numexpressionaux
    (52) term -> . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 69
    term                           shift and go to state 47
    unaryexpr                      shift and go to state 48
    factor                         shift and go to state 50
    lvalue                         shift and go to state 55

state 44

    (32) atribstat -> lvalue EQUAL . atribstat2
    (33) atribstat2 -> . expression
    (34) atribstat2 -> . allocexpression
    (35) atribstat2 -> . funccall
    (42) expression -> . numexpression expressionaux
    (41) allocexpression -> . NEW type numexpressionvectoraux
    (36) funccall -> . IDENTF LPAREN paramlistcall RPAREN
    (48) numexpression -> . term numexpressionaux
    (52) term -> . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    NEW             shift and go to state 74
    IDENTF          shift and go to state 75
    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    lvalue                         shift and go to state 55
    atribstat2                     shift and go to state 70
    expression                     shift and go to state 71
    allocexpression                shift and go to state 72
    funccall                       shift and go to state 73
    numexpression                  shift and go to state 46
    term                           shift and go to state 47
    unaryexpr                      shift and go to state 48
    factor                         shift and go to state 50

state 45

    (30) printstat -> PRINT expression .

    SEMICOLON       reduce using rule 30 (printstat -> PRINT expression .)


state 46

    (42) expression -> numexpression . expressionaux
    (43) expressionaux -> . COMPARISON numexpression
    (44) expressionaux -> . epsilon
    (72) epsilon -> .

    COMPARISON      shift and go to state 77
    SEMICOLON       reduce using rule 72 (epsilon -> .)
    RPAREN          reduce using rule 72 (epsilon -> .)

    expressionaux                  shift and go to state 76
    epsilon                        shift and go to state 78

state 47

    (48) numexpression -> term . numexpressionaux
    (49) numexpressionaux -> . numexpression2
    (50) numexpressionaux -> . epsilon
    (51) numexpression2 -> . SIGNAL term numexpressionaux
    (72) epsilon -> .

    SIGNAL          shift and go to state 82
    COMPARISON      reduce using rule 72 (epsilon -> .)
    SEMICOLON       reduce using rule 72 (epsilon -> .)
    RBRACKET        reduce using rule 72 (epsilon -> .)
    RPAREN          reduce using rule 72 (epsilon -> .)

    numexpressionaux               shift and go to state 79
    numexpression2                 shift and go to state 80
    epsilon                        shift and go to state 81

state 48

    (52) term -> unaryexpr . termaux
    (53) termaux -> . term2
    (54) termaux -> . epsilon
    (55) term2 -> . MATH unaryexpr termaux
    (72) epsilon -> .

    MATH            shift and go to state 86
    SIGNAL          reduce using rule 72 (epsilon -> .)
    COMPARISON      reduce using rule 72 (epsilon -> .)
    SEMICOLON       reduce using rule 72 (epsilon -> .)
    RBRACKET        reduce using rule 72 (epsilon -> .)
    RPAREN          reduce using rule 72 (epsilon -> .)

    termaux                        shift and go to state 83
    term2                          shift and go to state 84
    epsilon                        shift and go to state 85

state 49

    (56) unaryexpr -> SIGNAL . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    factor                         shift and go to state 87
    lvalue                         shift and go to state 55

state 50

    (57) unaryexpr -> factor .

    MATH            reduce using rule 57 (unaryexpr -> factor .)
    SIGNAL          reduce using rule 57 (unaryexpr -> factor .)
    COMPARISON      reduce using rule 57 (unaryexpr -> factor .)
    SEMICOLON       reduce using rule 57 (unaryexpr -> factor .)
    RBRACKET        reduce using rule 57 (unaryexpr -> factor .)
    RPAREN          reduce using rule 57 (unaryexpr -> factor .)


state 51

    (58) factor -> INTCONST .

    MATH            reduce using rule 58 (factor -> INTCONST .)
    SIGNAL          reduce using rule 58 (factor -> INTCONST .)
    COMPARISON      reduce using rule 58 (factor -> INTCONST .)
    SEMICOLON       reduce using rule 58 (factor -> INTCONST .)
    RBRACKET        reduce using rule 58 (factor -> INTCONST .)
    RPAREN          reduce using rule 58 (factor -> INTCONST .)


state 52

    (59) factor -> STRINGCONST .

    MATH            reduce using rule 59 (factor -> STRINGCONST .)
    SIGNAL          reduce using rule 59 (factor -> STRINGCONST .)
    COMPARISON      reduce using rule 59 (factor -> STRINGCONST .)
    SEMICOLON       reduce using rule 59 (factor -> STRINGCONST .)
    RBRACKET        reduce using rule 59 (factor -> STRINGCONST .)
    RPAREN          reduce using rule 59 (factor -> STRINGCONST .)


state 53

    (60) factor -> FLOATCONST .

    MATH            reduce using rule 60 (factor -> FLOATCONST .)
    SIGNAL          reduce using rule 60 (factor -> FLOATCONST .)
    COMPARISON      reduce using rule 60 (factor -> FLOATCONST .)
    SEMICOLON       reduce using rule 60 (factor -> FLOATCONST .)
    RBRACKET        reduce using rule 60 (factor -> FLOATCONST .)
    RPAREN          reduce using rule 60 (factor -> FLOATCONST .)


state 54

    (61) factor -> NULL .

    MATH            reduce using rule 61 (factor -> NULL .)
    SIGNAL          reduce using rule 61 (factor -> NULL .)
    COMPARISON      reduce using rule 61 (factor -> NULL .)
    SEMICOLON       reduce using rule 61 (factor -> NULL .)
    RBRACKET        reduce using rule 61 (factor -> NULL .)
    RPAREN          reduce using rule 61 (factor -> NULL .)


state 55

    (62) factor -> lvalue .

    MATH            reduce using rule 62 (factor -> lvalue .)
    SIGNAL          reduce using rule 62 (factor -> lvalue .)
    COMPARISON      reduce using rule 62 (factor -> lvalue .)
    SEMICOLON       reduce using rule 62 (factor -> lvalue .)
    RBRACKET        reduce using rule 62 (factor -> lvalue .)
    RPAREN          reduce using rule 62 (factor -> lvalue .)


state 56

    (63) factor -> LPAREN . numexpression RPAREN
    (48) numexpression -> . term numexpressionaux
    (52) term -> . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 88
    term                           shift and go to state 47
    unaryexpr                      shift and go to state 48
    factor                         shift and go to state 50
    lvalue                         shift and go to state 55

state 57

    (31) readstat -> READ expression .

    SEMICOLON       reduce using rule 31 (readstat -> READ expression .)


state 58

    (26) ifstat -> IF LPAREN . expression RPAREN statement ifstataux
    (42) expression -> . numexpression expressionaux
    (48) numexpression -> . term numexpressionaux
    (52) term -> . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    expression                     shift and go to state 89
    numexpression                  shift and go to state 46
    term                           shift and go to state 47
    unaryexpr                      shift and go to state 48
    factor                         shift and go to state 50
    lvalue                         shift and go to state 55

state 59

    (25) forstat -> FOR LPAREN . atribstat SEMICOLON expression SEMICOLON atribstat RPAREN
    (32) atribstat -> . lvalue EQUAL atribstat2
    (64) lvalue -> . IDENT numexpressionvectoraux

    IDENT           shift and go to state 17

    atribstat                      shift and go to state 90
    lvalue                         shift and go to state 18

state 60

    (7) funcdef -> DEF IDENTF . LPAREN paramlist RPAREN LBRACE statelist RBRACE

    LPAREN          shift and go to state 91


state 61

    (22) statement -> LBRACE statelist RBRACE .

    $end            reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    LBRACE          reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    BREAK           reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    SEMICOLON       reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    PRINT           reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    READ            reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    RETURN          reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    IF              reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    FOR             reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    INT             reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    FLOAT           reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    STRING          reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    IDENT           reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    RBRACE          reduce using rule 22 (statement -> LBRACE statelist RBRACE .)
    ELSE            reduce using rule 22 (statement -> LBRACE statelist RBRACE .)


state 62

    (12) statelist -> statement statelistaux .

    RBRACE          reduce using rule 12 (statelist -> statement statelistaux .)


state 63

    (13) statelistaux -> statelist .

    RBRACE          reduce using rule 13 (statelistaux -> statelist .)


state 64

    (14) statelistaux -> epsilon .

    RBRACE          reduce using rule 14 (statelistaux -> epsilon .)


state 65

    (65) vardecl -> type IDENT vardeclaux .

    SEMICOLON       reduce using rule 65 (vardecl -> type IDENT vardeclaux .)


state 66

    (66) vardeclaux -> vardecl2 .

    SEMICOLON       reduce using rule 66 (vardeclaux -> vardecl2 .)


state 67

    (67) vardeclaux -> epsilon .

    SEMICOLON       reduce using rule 67 (vardeclaux -> epsilon .)


state 68

    (68) vardecl2 -> LBRACKET . INTCONST RBRACKET vardeclaux

    INTCONST        shift and go to state 92


state 69

    (45) numexpressionvector -> LBRACKET numexpression . RBRACKET numexpressionvectoraux

    RBRACKET        shift and go to state 93


state 70

    (32) atribstat -> lvalue EQUAL atribstat2 .

    SEMICOLON       reduce using rule 32 (atribstat -> lvalue EQUAL atribstat2 .)
    RPAREN          reduce using rule 32 (atribstat -> lvalue EQUAL atribstat2 .)


state 71

    (33) atribstat2 -> expression .

    SEMICOLON       reduce using rule 33 (atribstat2 -> expression .)
    RPAREN          reduce using rule 33 (atribstat2 -> expression .)


state 72

    (34) atribstat2 -> allocexpression .

    SEMICOLON       reduce using rule 34 (atribstat2 -> allocexpression .)
    RPAREN          reduce using rule 34 (atribstat2 -> allocexpression .)


state 73

    (35) atribstat2 -> funccall .

    SEMICOLON       reduce using rule 35 (atribstat2 -> funccall .)
    RPAREN          reduce using rule 35 (atribstat2 -> funccall .)


state 74

    (41) allocexpression -> NEW . type numexpressionvectoraux
    (69) type -> . INT
    (70) type -> . FLOAT
    (71) type -> . STRING

    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    STRING          shift and go to state 27

    type                           shift and go to state 94

state 75

    (36) funccall -> IDENTF . LPAREN paramlistcall RPAREN

    LPAREN          shift and go to state 95


state 76

    (42) expression -> numexpression expressionaux .

    SEMICOLON       reduce using rule 42 (expression -> numexpression expressionaux .)
    RPAREN          reduce using rule 42 (expression -> numexpression expressionaux .)


state 77

    (43) expressionaux -> COMPARISON . numexpression
    (48) numexpression -> . term numexpressionaux
    (52) term -> . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 96
    term                           shift and go to state 47
    unaryexpr                      shift and go to state 48
    factor                         shift and go to state 50
    lvalue                         shift and go to state 55

state 78

    (44) expressionaux -> epsilon .

    SEMICOLON       reduce using rule 44 (expressionaux -> epsilon .)
    RPAREN          reduce using rule 44 (expressionaux -> epsilon .)


state 79

    (48) numexpression -> term numexpressionaux .

    COMPARISON      reduce using rule 48 (numexpression -> term numexpressionaux .)
    SEMICOLON       reduce using rule 48 (numexpression -> term numexpressionaux .)
    RBRACKET        reduce using rule 48 (numexpression -> term numexpressionaux .)
    RPAREN          reduce using rule 48 (numexpression -> term numexpressionaux .)


state 80

    (49) numexpressionaux -> numexpression2 .

    COMPARISON      reduce using rule 49 (numexpressionaux -> numexpression2 .)
    SEMICOLON       reduce using rule 49 (numexpressionaux -> numexpression2 .)
    RBRACKET        reduce using rule 49 (numexpressionaux -> numexpression2 .)
    RPAREN          reduce using rule 49 (numexpressionaux -> numexpression2 .)


state 81

    (50) numexpressionaux -> epsilon .

    COMPARISON      reduce using rule 50 (numexpressionaux -> epsilon .)
    SEMICOLON       reduce using rule 50 (numexpressionaux -> epsilon .)
    RBRACKET        reduce using rule 50 (numexpressionaux -> epsilon .)
    RPAREN          reduce using rule 50 (numexpressionaux -> epsilon .)


state 82

    (51) numexpression2 -> SIGNAL . term numexpressionaux
    (52) term -> . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    term                           shift and go to state 97
    unaryexpr                      shift and go to state 48
    factor                         shift and go to state 50
    lvalue                         shift and go to state 55

state 83

    (52) term -> unaryexpr termaux .

    SIGNAL          reduce using rule 52 (term -> unaryexpr termaux .)
    COMPARISON      reduce using rule 52 (term -> unaryexpr termaux .)
    SEMICOLON       reduce using rule 52 (term -> unaryexpr termaux .)
    RBRACKET        reduce using rule 52 (term -> unaryexpr termaux .)
    RPAREN          reduce using rule 52 (term -> unaryexpr termaux .)


state 84

    (53) termaux -> term2 .

    SIGNAL          reduce using rule 53 (termaux -> term2 .)
    COMPARISON      reduce using rule 53 (termaux -> term2 .)
    SEMICOLON       reduce using rule 53 (termaux -> term2 .)
    RBRACKET        reduce using rule 53 (termaux -> term2 .)
    RPAREN          reduce using rule 53 (termaux -> term2 .)


state 85

    (54) termaux -> epsilon .

    SIGNAL          reduce using rule 54 (termaux -> epsilon .)
    COMPARISON      reduce using rule 54 (termaux -> epsilon .)
    SEMICOLON       reduce using rule 54 (termaux -> epsilon .)
    RBRACKET        reduce using rule 54 (termaux -> epsilon .)
    RPAREN          reduce using rule 54 (termaux -> epsilon .)


state 86

    (55) term2 -> MATH . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    unaryexpr                      shift and go to state 98
    factor                         shift and go to state 50
    lvalue                         shift and go to state 55

state 87

    (56) unaryexpr -> SIGNAL factor .

    MATH            reduce using rule 56 (unaryexpr -> SIGNAL factor .)
    SIGNAL          reduce using rule 56 (unaryexpr -> SIGNAL factor .)
    COMPARISON      reduce using rule 56 (unaryexpr -> SIGNAL factor .)
    SEMICOLON       reduce using rule 56 (unaryexpr -> SIGNAL factor .)
    RBRACKET        reduce using rule 56 (unaryexpr -> SIGNAL factor .)
    RPAREN          reduce using rule 56 (unaryexpr -> SIGNAL factor .)


state 88

    (63) factor -> LPAREN numexpression . RPAREN

    RPAREN          shift and go to state 99


state 89

    (26) ifstat -> IF LPAREN expression . RPAREN statement ifstataux

    RPAREN          shift and go to state 100


state 90

    (25) forstat -> FOR LPAREN atribstat . SEMICOLON expression SEMICOLON atribstat RPAREN

    SEMICOLON       shift and go to state 101


state 91

    (7) funcdef -> DEF IDENTF LPAREN . paramlist RPAREN LBRACE statelist RBRACE
    (8) paramlist -> . type IDENT paramlistaux
    (9) paramlist -> . epsilon
    (69) type -> . INT
    (70) type -> . FLOAT
    (71) type -> . STRING
    (72) epsilon -> .

    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    STRING          shift and go to state 27
    RPAREN          reduce using rule 72 (epsilon -> .)

    paramlist                      shift and go to state 102
    type                           shift and go to state 103
    epsilon                        shift and go to state 104

state 92

    (68) vardecl2 -> LBRACKET INTCONST . RBRACKET vardeclaux

    RBRACKET        shift and go to state 105


state 93

    (45) numexpressionvector -> LBRACKET numexpression RBRACKET . numexpressionvectoraux
    (46) numexpressionvectoraux -> . numexpressionvector
    (47) numexpressionvectoraux -> . epsilon
    (45) numexpressionvector -> . LBRACKET numexpression RBRACKET numexpressionvectoraux
    (72) epsilon -> .

    LBRACKET        shift and go to state 43
    EQUAL           reduce using rule 72 (epsilon -> .)
    MATH            reduce using rule 72 (epsilon -> .)
    SIGNAL          reduce using rule 72 (epsilon -> .)
    COMPARISON      reduce using rule 72 (epsilon -> .)
    SEMICOLON       reduce using rule 72 (epsilon -> .)
    RBRACKET        reduce using rule 72 (epsilon -> .)
    RPAREN          reduce using rule 72 (epsilon -> .)

    numexpressionvectoraux         shift and go to state 106
    numexpressionvector            shift and go to state 41
    epsilon                        shift and go to state 42

state 94

    (41) allocexpression -> NEW type . numexpressionvectoraux
    (46) numexpressionvectoraux -> . numexpressionvector
    (47) numexpressionvectoraux -> . epsilon
    (45) numexpressionvector -> . LBRACKET numexpression RBRACKET numexpressionvectoraux
    (72) epsilon -> .

    LBRACKET        shift and go to state 43
    SEMICOLON       reduce using rule 72 (epsilon -> .)
    RPAREN          reduce using rule 72 (epsilon -> .)

    numexpressionvectoraux         shift and go to state 107
    numexpressionvector            shift and go to state 41
    epsilon                        shift and go to state 42

state 95

    (36) funccall -> IDENTF LPAREN . paramlistcall RPAREN
    (37) paramlistcall -> . IDENT paramlistcallaux
    (38) paramlistcall -> . epsilon
    (72) epsilon -> .

    IDENT           shift and go to state 109
    RPAREN          reduce using rule 72 (epsilon -> .)

    paramlistcall                  shift and go to state 108
    epsilon                        shift and go to state 110

state 96

    (43) expressionaux -> COMPARISON numexpression .

    SEMICOLON       reduce using rule 43 (expressionaux -> COMPARISON numexpression .)
    RPAREN          reduce using rule 43 (expressionaux -> COMPARISON numexpression .)


state 97

    (51) numexpression2 -> SIGNAL term . numexpressionaux
    (49) numexpressionaux -> . numexpression2
    (50) numexpressionaux -> . epsilon
    (51) numexpression2 -> . SIGNAL term numexpressionaux
    (72) epsilon -> .

    SIGNAL          shift and go to state 82
    COMPARISON      reduce using rule 72 (epsilon -> .)
    SEMICOLON       reduce using rule 72 (epsilon -> .)
    RBRACKET        reduce using rule 72 (epsilon -> .)
    RPAREN          reduce using rule 72 (epsilon -> .)

    numexpressionaux               shift and go to state 111
    numexpression2                 shift and go to state 80
    epsilon                        shift and go to state 81

state 98

    (55) term2 -> MATH unaryexpr . termaux
    (53) termaux -> . term2
    (54) termaux -> . epsilon
    (55) term2 -> . MATH unaryexpr termaux
    (72) epsilon -> .

    MATH            shift and go to state 86
    SIGNAL          reduce using rule 72 (epsilon -> .)
    COMPARISON      reduce using rule 72 (epsilon -> .)
    SEMICOLON       reduce using rule 72 (epsilon -> .)
    RBRACKET        reduce using rule 72 (epsilon -> .)
    RPAREN          reduce using rule 72 (epsilon -> .)

    termaux                        shift and go to state 112
    term2                          shift and go to state 84
    epsilon                        shift and go to state 85

state 99

    (63) factor -> LPAREN numexpression RPAREN .

    MATH            reduce using rule 63 (factor -> LPAREN numexpression RPAREN .)
    SIGNAL          reduce using rule 63 (factor -> LPAREN numexpression RPAREN .)
    COMPARISON      reduce using rule 63 (factor -> LPAREN numexpression RPAREN .)
    SEMICOLON       reduce using rule 63 (factor -> LPAREN numexpression RPAREN .)
    RBRACKET        reduce using rule 63 (factor -> LPAREN numexpression RPAREN .)
    RPAREN          reduce using rule 63 (factor -> LPAREN numexpression RPAREN .)


state 100

    (26) ifstat -> IF LPAREN expression RPAREN . statement ifstataux
    (15) statement -> . vardecl SEMICOLON
    (16) statement -> . atribstat SEMICOLON
    (17) statement -> . printstat SEMICOLON
    (18) statement -> . readstat SEMICOLON
    (19) statement -> . returnstat SEMICOLON
    (20) statement -> . ifstat
    (21) statement -> . forstat
    (22) statement -> . LBRACE statelist RBRACE
    (23) statement -> . BREAK SEMICOLON
    (24) statement -> . SEMICOLON
    (65) vardecl -> . type IDENT vardeclaux
    (32) atribstat -> . lvalue EQUAL atribstat2
    (30) printstat -> . PRINT expression
    (31) readstat -> . READ expression
    (29) returnstat -> . RETURN
    (26) ifstat -> . IF LPAREN expression RPAREN statement ifstataux
    (25) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN
    (69) type -> . INT
    (70) type -> . FLOAT
    (71) type -> . STRING
    (64) lvalue -> . IDENT numexpressionvectoraux

    LBRACE          shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    PRINT           shift and go to state 19
    READ            shift and go to state 20
    RETURN          shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    STRING          shift and go to state 27
    IDENT           shift and go to state 17

    statement                      shift and go to state 113
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    type                           shift and go to state 16
    lvalue                         shift and go to state 18

state 101

    (25) forstat -> FOR LPAREN atribstat SEMICOLON . expression SEMICOLON atribstat RPAREN
    (42) expression -> . numexpression expressionaux
    (48) numexpression -> . term numexpressionaux
    (52) term -> . unaryexpr termaux
    (56) unaryexpr -> . SIGNAL factor
    (57) unaryexpr -> . factor
    (58) factor -> . INTCONST
    (59) factor -> . STRINGCONST
    (60) factor -> . FLOATCONST
    (61) factor -> . NULL
    (62) factor -> . lvalue
    (63) factor -> . LPAREN numexpression RPAREN
    (64) lvalue -> . IDENT numexpressionvectoraux

    SIGNAL          shift and go to state 49
    INTCONST        shift and go to state 51
    STRINGCONST     shift and go to state 52
    FLOATCONST      shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    expression                     shift and go to state 114
    numexpression                  shift and go to state 46
    term                           shift and go to state 47
    unaryexpr                      shift and go to state 48
    factor                         shift and go to state 50
    lvalue                         shift and go to state 55

state 102

    (7) funcdef -> DEF IDENTF LPAREN paramlist . RPAREN LBRACE statelist RBRACE

    RPAREN          shift and go to state 115


state 103

    (8) paramlist -> type . IDENT paramlistaux

    IDENT           shift and go to state 116


state 104

    (9) paramlist -> epsilon .

    RPAREN          reduce using rule 9 (paramlist -> epsilon .)


state 105

    (68) vardecl2 -> LBRACKET INTCONST RBRACKET . vardeclaux
    (66) vardeclaux -> . vardecl2
    (67) vardeclaux -> . epsilon
    (68) vardecl2 -> . LBRACKET INTCONST RBRACKET vardeclaux
    (72) epsilon -> .

    LBRACKET        shift and go to state 68
    SEMICOLON       reduce using rule 72 (epsilon -> .)

    vardeclaux                     shift and go to state 117
    vardecl2                       shift and go to state 66
    epsilon                        shift and go to state 67

state 106

    (45) numexpressionvector -> LBRACKET numexpression RBRACKET numexpressionvectoraux .

    EQUAL           reduce using rule 45 (numexpressionvector -> LBRACKET numexpression RBRACKET numexpressionvectoraux .)
    MATH            reduce using rule 45 (numexpressionvector -> LBRACKET numexpression RBRACKET numexpressionvectoraux .)
    SIGNAL          reduce using rule 45 (numexpressionvector -> LBRACKET numexpression RBRACKET numexpressionvectoraux .)
    COMPARISON      reduce using rule 45 (numexpressionvector -> LBRACKET numexpression RBRACKET numexpressionvectoraux .)
    SEMICOLON       reduce using rule 45 (numexpressionvector -> LBRACKET numexpression RBRACKET numexpressionvectoraux .)
    RBRACKET        reduce using rule 45 (numexpressionvector -> LBRACKET numexpression RBRACKET numexpressionvectoraux .)
    RPAREN          reduce using rule 45 (numexpressionvector -> LBRACKET numexpression RBRACKET numexpressionvectoraux .)


state 107

    (41) allocexpression -> NEW type numexpressionvectoraux .

    SEMICOLON       reduce using rule 41 (allocexpression -> NEW type numexpressionvectoraux .)
    RPAREN          reduce using rule 41 (allocexpression -> NEW type numexpressionvectoraux .)


state 108

    (36) funccall -> IDENTF LPAREN paramlistcall . RPAREN

    RPAREN          shift and go to state 118


state 109

    (37) paramlistcall -> IDENT . paramlistcallaux
    (39) paramlistcallaux -> . COLON paramlistcall
    (40) paramlistcallaux -> . epsilon
    (72) epsilon -> .

    COLON           shift and go to state 120
    RPAREN          reduce using rule 72 (epsilon -> .)

    paramlistcallaux               shift and go to state 119
    epsilon                        shift and go to state 121

state 110

    (38) paramlistcall -> epsilon .

    RPAREN          reduce using rule 38 (paramlistcall -> epsilon .)


state 111

    (51) numexpression2 -> SIGNAL term numexpressionaux .

    COMPARISON      reduce using rule 51 (numexpression2 -> SIGNAL term numexpressionaux .)
    SEMICOLON       reduce using rule 51 (numexpression2 -> SIGNAL term numexpressionaux .)
    RBRACKET        reduce using rule 51 (numexpression2 -> SIGNAL term numexpressionaux .)
    RPAREN          reduce using rule 51 (numexpression2 -> SIGNAL term numexpressionaux .)


state 112

    (55) term2 -> MATH unaryexpr termaux .

    SIGNAL          reduce using rule 55 (term2 -> MATH unaryexpr termaux .)
    COMPARISON      reduce using rule 55 (term2 -> MATH unaryexpr termaux .)
    SEMICOLON       reduce using rule 55 (term2 -> MATH unaryexpr termaux .)
    RBRACKET        reduce using rule 55 (term2 -> MATH unaryexpr termaux .)
    RPAREN          reduce using rule 55 (term2 -> MATH unaryexpr termaux .)


state 113

    (26) ifstat -> IF LPAREN expression RPAREN statement . ifstataux
    (27) ifstataux -> . ELSE statement
    (28) ifstataux -> . epsilon
    (72) epsilon -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 123
    $end            reduce using rule 72 (epsilon -> .)
    LBRACE          reduce using rule 72 (epsilon -> .)
    BREAK           reduce using rule 72 (epsilon -> .)
    SEMICOLON       reduce using rule 72 (epsilon -> .)
    PRINT           reduce using rule 72 (epsilon -> .)
    READ            reduce using rule 72 (epsilon -> .)
    RETURN          reduce using rule 72 (epsilon -> .)
    IF              reduce using rule 72 (epsilon -> .)
    FOR             reduce using rule 72 (epsilon -> .)
    INT             reduce using rule 72 (epsilon -> .)
    FLOAT           reduce using rule 72 (epsilon -> .)
    STRING          reduce using rule 72 (epsilon -> .)
    IDENT           reduce using rule 72 (epsilon -> .)
    RBRACE          reduce using rule 72 (epsilon -> .)

  ! ELSE            [ reduce using rule 72 (epsilon -> .) ]

    ifstataux                      shift and go to state 122
    epsilon                        shift and go to state 124

state 114

    (25) forstat -> FOR LPAREN atribstat SEMICOLON expression . SEMICOLON atribstat RPAREN

    SEMICOLON       shift and go to state 125


state 115

    (7) funcdef -> DEF IDENTF LPAREN paramlist RPAREN . LBRACE statelist RBRACE

    LBRACE          shift and go to state 126


state 116

    (8) paramlist -> type IDENT . paramlistaux
    (10) paramlistaux -> . COLON paramlist
    (11) paramlistaux -> . epsilon
    (72) epsilon -> .

    COLON           shift and go to state 128
    RPAREN          reduce using rule 72 (epsilon -> .)

    paramlistaux                   shift and go to state 127
    epsilon                        shift and go to state 129

state 117

    (68) vardecl2 -> LBRACKET INTCONST RBRACKET vardeclaux .

    SEMICOLON       reduce using rule 68 (vardecl2 -> LBRACKET INTCONST RBRACKET vardeclaux .)


state 118

    (36) funccall -> IDENTF LPAREN paramlistcall RPAREN .

    SEMICOLON       reduce using rule 36 (funccall -> IDENTF LPAREN paramlistcall RPAREN .)
    RPAREN          reduce using rule 36 (funccall -> IDENTF LPAREN paramlistcall RPAREN .)


state 119

    (37) paramlistcall -> IDENT paramlistcallaux .

    RPAREN          reduce using rule 37 (paramlistcall -> IDENT paramlistcallaux .)


state 120

    (39) paramlistcallaux -> COLON . paramlistcall
    (37) paramlistcall -> . IDENT paramlistcallaux
    (38) paramlistcall -> . epsilon
    (72) epsilon -> .

    IDENT           shift and go to state 109
    RPAREN          reduce using rule 72 (epsilon -> .)

    paramlistcall                  shift and go to state 130
    epsilon                        shift and go to state 110

state 121

    (40) paramlistcallaux -> epsilon .

    RPAREN          reduce using rule 40 (paramlistcallaux -> epsilon .)


state 122

    (26) ifstat -> IF LPAREN expression RPAREN statement ifstataux .

    $end            reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    LBRACE          reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    BREAK           reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    SEMICOLON       reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    PRINT           reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    READ            reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    RETURN          reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    IF              reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    FOR             reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    INT             reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    FLOAT           reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    STRING          reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    IDENT           reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    RBRACE          reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)
    ELSE            reduce using rule 26 (ifstat -> IF LPAREN expression RPAREN statement ifstataux .)


state 123

    (27) ifstataux -> ELSE . statement
    (15) statement -> . vardecl SEMICOLON
    (16) statement -> . atribstat SEMICOLON
    (17) statement -> . printstat SEMICOLON
    (18) statement -> . readstat SEMICOLON
    (19) statement -> . returnstat SEMICOLON
    (20) statement -> . ifstat
    (21) statement -> . forstat
    (22) statement -> . LBRACE statelist RBRACE
    (23) statement -> . BREAK SEMICOLON
    (24) statement -> . SEMICOLON
    (65) vardecl -> . type IDENT vardeclaux
    (32) atribstat -> . lvalue EQUAL atribstat2
    (30) printstat -> . PRINT expression
    (31) readstat -> . READ expression
    (29) returnstat -> . RETURN
    (26) ifstat -> . IF LPAREN expression RPAREN statement ifstataux
    (25) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN
    (69) type -> . INT
    (70) type -> . FLOAT
    (71) type -> . STRING
    (64) lvalue -> . IDENT numexpressionvectoraux

    LBRACE          shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    PRINT           shift and go to state 19
    READ            shift and go to state 20
    RETURN          shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    STRING          shift and go to state 27
    IDENT           shift and go to state 17

    statement                      shift and go to state 131
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    type                           shift and go to state 16
    lvalue                         shift and go to state 18

state 124

    (28) ifstataux -> epsilon .

    ELSE            reduce using rule 28 (ifstataux -> epsilon .)
    $end            reduce using rule 28 (ifstataux -> epsilon .)
    LBRACE          reduce using rule 28 (ifstataux -> epsilon .)
    BREAK           reduce using rule 28 (ifstataux -> epsilon .)
    SEMICOLON       reduce using rule 28 (ifstataux -> epsilon .)
    PRINT           reduce using rule 28 (ifstataux -> epsilon .)
    READ            reduce using rule 28 (ifstataux -> epsilon .)
    RETURN          reduce using rule 28 (ifstataux -> epsilon .)
    IF              reduce using rule 28 (ifstataux -> epsilon .)
    FOR             reduce using rule 28 (ifstataux -> epsilon .)
    INT             reduce using rule 28 (ifstataux -> epsilon .)
    FLOAT           reduce using rule 28 (ifstataux -> epsilon .)
    STRING          reduce using rule 28 (ifstataux -> epsilon .)
    IDENT           reduce using rule 28 (ifstataux -> epsilon .)
    RBRACE          reduce using rule 28 (ifstataux -> epsilon .)


state 125

    (25) forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON . atribstat RPAREN
    (32) atribstat -> . lvalue EQUAL atribstat2
    (64) lvalue -> . IDENT numexpressionvectoraux

    IDENT           shift and go to state 17

    atribstat                      shift and go to state 132
    lvalue                         shift and go to state 18

state 126

    (7) funcdef -> DEF IDENTF LPAREN paramlist RPAREN LBRACE . statelist RBRACE
    (12) statelist -> . statement statelistaux
    (15) statement -> . vardecl SEMICOLON
    (16) statement -> . atribstat SEMICOLON
    (17) statement -> . printstat SEMICOLON
    (18) statement -> . readstat SEMICOLON
    (19) statement -> . returnstat SEMICOLON
    (20) statement -> . ifstat
    (21) statement -> . forstat
    (22) statement -> . LBRACE statelist RBRACE
    (23) statement -> . BREAK SEMICOLON
    (24) statement -> . SEMICOLON
    (65) vardecl -> . type IDENT vardeclaux
    (32) atribstat -> . lvalue EQUAL atribstat2
    (30) printstat -> . PRINT expression
    (31) readstat -> . READ expression
    (29) returnstat -> . RETURN
    (26) ifstat -> . IF LPAREN expression RPAREN statement ifstataux
    (25) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN
    (69) type -> . INT
    (70) type -> . FLOAT
    (71) type -> . STRING
    (64) lvalue -> . IDENT numexpressionvectoraux

    LBRACE          shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    PRINT           shift and go to state 19
    READ            shift and go to state 20
    RETURN          shift and go to state 21
    IF              shift and go to state 22
    FOR             shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    STRING          shift and go to state 27
    IDENT           shift and go to state 17

    statelist                      shift and go to state 133
    statement                      shift and go to state 34
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    type                           shift and go to state 16
    lvalue                         shift and go to state 18

state 127

    (8) paramlist -> type IDENT paramlistaux .

    RPAREN          reduce using rule 8 (paramlist -> type IDENT paramlistaux .)


state 128

    (10) paramlistaux -> COLON . paramlist
    (8) paramlist -> . type IDENT paramlistaux
    (9) paramlist -> . epsilon
    (69) type -> . INT
    (70) type -> . FLOAT
    (71) type -> . STRING
    (72) epsilon -> .

    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    STRING          shift and go to state 27
    RPAREN          reduce using rule 72 (epsilon -> .)

    paramlist                      shift and go to state 134
    type                           shift and go to state 103
    epsilon                        shift and go to state 104

state 129

    (11) paramlistaux -> epsilon .

    RPAREN          reduce using rule 11 (paramlistaux -> epsilon .)


state 130

    (39) paramlistcallaux -> COLON paramlistcall .

    RPAREN          reduce using rule 39 (paramlistcallaux -> COLON paramlistcall .)


state 131

    (27) ifstataux -> ELSE statement .

    ELSE            reduce using rule 27 (ifstataux -> ELSE statement .)
    $end            reduce using rule 27 (ifstataux -> ELSE statement .)
    LBRACE          reduce using rule 27 (ifstataux -> ELSE statement .)
    BREAK           reduce using rule 27 (ifstataux -> ELSE statement .)
    SEMICOLON       reduce using rule 27 (ifstataux -> ELSE statement .)
    PRINT           reduce using rule 27 (ifstataux -> ELSE statement .)
    READ            reduce using rule 27 (ifstataux -> ELSE statement .)
    RETURN          reduce using rule 27 (ifstataux -> ELSE statement .)
    IF              reduce using rule 27 (ifstataux -> ELSE statement .)
    FOR             reduce using rule 27 (ifstataux -> ELSE statement .)
    INT             reduce using rule 27 (ifstataux -> ELSE statement .)
    FLOAT           reduce using rule 27 (ifstataux -> ELSE statement .)
    STRING          reduce using rule 27 (ifstataux -> ELSE statement .)
    IDENT           reduce using rule 27 (ifstataux -> ELSE statement .)
    RBRACE          reduce using rule 27 (ifstataux -> ELSE statement .)


state 132

    (25) forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat . RPAREN

    RPAREN          shift and go to state 135


state 133

    (7) funcdef -> DEF IDENTF LPAREN paramlist RPAREN LBRACE statelist . RBRACE

    RBRACE          shift and go to state 136


state 134

    (10) paramlistaux -> COLON paramlist .

    RPAREN          reduce using rule 10 (paramlistaux -> COLON paramlist .)


state 135

    (25) forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .

    $end            reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    LBRACE          reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    BREAK           reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    SEMICOLON       reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    PRINT           reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    READ            reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    RETURN          reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    IF              reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    FOR             reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    INT             reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    FLOAT           reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    STRING          reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    IDENT           reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    RBRACE          reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)
    ELSE            reduce using rule 25 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN .)


state 136

    (7) funcdef -> DEF IDENTF LPAREN paramlist RPAREN LBRACE statelist RBRACE .

    DEF             reduce using rule 7 (funcdef -> DEF IDENTF LPAREN paramlist RPAREN LBRACE statelist RBRACE .)
    $end            reduce using rule 7 (funcdef -> DEF IDENTF LPAREN paramlist RPAREN LBRACE statelist RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 113 resolved as shift
